// AI-tutor-v1.0/ai translation/üìö Vocabulary/Views/QuizView.swift

import SwiftUI

struct QuizView: View {
    let quiz: QuizResponse
    let type: PracticeType
    let onComplete: (StudySummary) -> Void
    
    @Environment(\.dismiss) private var dismiss
    @StateObject private var vocabularyService = VocabularyService()
    
    @State private var currentIndex = 0
    @State private var selectedAnswer: String?
    @State private var selectedIndex: Int?
    @State private var userInput: String = ""
    @State private var correctAnswers = 0
    @State private var startTime = Date()
    @State private var questionStartTime = Date()
    @State private var studiedWords: [VocabularyWord] = []
    @State private var isSubmittingReview = false
    @State private var showingResult = false
    @State private var isAnswered = false
    
    private var currentQuestion: QuizQuestion? {
        guard currentIndex < quiz.questions.count else { return nil }
        return quiz.questions[currentIndex]
    }
    
    private var progress: Double {
        Double(currentIndex) / Double(quiz.questions.count)
    }
    
    var body: some View {
        GeometryReader { geometry in
            VStack(spacing: 0) {
                // È†ÇÈÉ®Â∞éËà™Ê¨Ñ
                topNavigationBar
                
                // ÈÄ≤Â∫¶Ê¢ù
                progressBar
                
                // ÂïèÈ°åÂçÄÂüü
                if let question = currentQuestion {
                    questionArea(question: question, in: geometry)
                } else {
                    studyCompleteView
                }
                
                Spacer()
                
                // Â∫ïÈÉ®ÊéßÂà∂ÂçÄÂüü
                if currentQuestion != nil {
                    bottomControlArea
                }
            }
        }
        .background(Color.modernBackground)
        .onAppear {
            startTime = Date()
            questionStartTime = Date()
        }
    }
    
    // MARK: - È†ÇÈÉ®Â∞éËà™
    
    private var topNavigationBar: some View {
        HStack {
            ModernButton(
                "ÁµêÊùü",
                style: .tertiary
            ) {
                dismiss()
            }
            
            Spacer()
            
            Text(type == .multipleChoice ? "ÈÅ∏ÊìáÈ°åÊ∏¨È©ó" : "Ë™ûÂ¢ÉÂ°´Á©∫")
                .font(.appHeadline(for: "Ê∏¨È©óÊ®ôÈ°å"))
                .foregroundStyle(Color.modernTextPrimary)
            
            Spacer()
            
            Text("\(currentIndex + 1)/\(quiz.questions.count)")
                .font(.appSubheadline(for: "ÂïèÈ°åË®àÊï∏"))
                .foregroundStyle(Color.modernTextSecondary)
        }
        .padding(ModernSpacing.md)
    }
    
    // MARK: - ÈÄ≤Â∫¶Ê¢ù
    
    private var progressBar: some View {
        VStack(spacing: ModernSpacing.xs) {
            ProgressView(value: progress)
                .progressViewStyle(LinearProgressViewStyle(tint: Color.modernAccent))
                .scaleEffect(x: 1, y: 2, anchor: .center)
            
            HStack {
                Text("Â∑≤ÂÆåÊàê \(currentIndex)")
                    .font(.appCaption(for: "ÈÄ≤Â∫¶ÊñáÂ≠ó"))
                    .foregroundStyle(Color.modernTextSecondary)
                
                Spacer()
                
                Text("Ê≠£Á¢∫Áéá: \(safeAccuracyPercentage)%")
                    .font(.appCaption(for: "Ê≠£Á¢∫Áéá"))
                    .foregroundStyle(Color.modernAccent)
            }
        }
        .padding(.horizontal, ModernSpacing.md)
    }
    
    // MARK: - ÂïèÈ°åÂçÄÂüü
    
    private func questionArea(question: QuizQuestion, in geometry: GeometryProxy) -> some View {
        ScrollView {
            VStack(spacing: ModernSpacing.lg) {
                // ÂïèÈ°åÂç°Áâá
                questionCard(question: question)
                
                // Á≠îÈ°åÂçÄÂüü
                if type == .multipleChoice {
                    multipleChoiceOptions(question: question)
                } else {
                    contextFillInput(question: question)
                }
                
                // ÁµêÊûúÈ°ØÁ§∫
                if showingResult {
                    resultCard(question: question)
                }
            }
            .padding(ModernSpacing.md)
        }
    }
    
    // MARK: - ÂïèÈ°åÂç°Áâá
    
    private func questionCard(question: QuizQuestion) -> some View {
        VStack(spacing: ModernSpacing.md) {
            // ÂñÆÂ≠óÊàñÂïèÈ°å
            if type == .multipleChoice {
                VStack(spacing: ModernSpacing.sm) {
                    Text(question.word)
                        .font(.appLargeTitle(for: "Ê∏¨È©óÂñÆÂ≠ó"))
                        .foregroundStyle(Color.modernTextPrimary)
                    
                    if let pronunciation = question.pronunciation {
                        Text("/\(pronunciation)/")
                            .font(.appTitle2(for: "ÂñÆÂ≠óÁôºÈü≥"))
                            .foregroundStyle(Color.modernSpecial)
                    }
                    
                    if let partOfSpeech = question.partOfSpeech {
                        Text(partOfSpeech)
                            .font(.appCallout(for: "Ë©ûÊÄßÊ®ôÁ±§"))
                            .foregroundStyle(Color.modernAccent)
                            .padding(.horizontal, ModernSpacing.sm)
                            .padding(.vertical, ModernSpacing.xs)
                            .background {
                                RoundedRectangle(cornerRadius: ModernRadius.xs)
                                    .fill(Color.modernAccentSoft)
                            }
                    }
                    
                    Text("ÈÅ∏ÊìáÊ≠£Á¢∫ÁöÑ‰∏≠ÊñáÊÑèÊÄùÔºö")
                        .font(.appSubheadline(for: "ÈÅ∏ÊìáÊèêÁ§∫"))
                        .foregroundStyle(Color.modernTextSecondary)
                }
            } else {
                // Ë™ûÂ¢ÉÂ°´Á©∫
                VStack(spacing: ModernSpacing.sm) {
                    Text("Âú®‰∏ãÂàóÂè•Â≠ê‰∏≠Â°´ÂÖ•Ê≠£Á¢∫ÁöÑÂñÆÂ≠óÔºö")
                        .font(.appHeadline(for: "Â°´Á©∫ÊèêÁ§∫"))
                        .foregroundStyle(Color.modernTextPrimary)
                    
                    if let questionSentence = question.questionSentence {
                        Text(questionSentence)
                            .font(.appTitle2(for: "ÂïèÈ°åÂè•Â≠ê"))
                            .foregroundStyle(Color.modernTextPrimary)
                            .padding(ModernSpacing.md)
                            .background {
                                RoundedRectangle(cornerRadius: ModernRadius.sm)
                                    .fill(Color.modernSurface)
                            }
                            .multilineTextAlignment(.center)
                    }
                    
                    if let hints = question.hints, !hints.isEmpty {
                        VStack(alignment: .leading, spacing: ModernSpacing.xs) {
                            Text("ÊèêÁ§∫Ôºö")
                                .font(.appCaption(for: "ÊèêÁ§∫Ê®ôÁ±§"))
                                .foregroundStyle(Color.modernTextSecondary)
                            
                            ForEach(hints, id: \.self) { hint in
                                Text("‚Ä¢ \(hint)")
                                    .font(.appCaption(for: "ÊèêÁ§∫ÂÖßÂÆπ"))
                                    .foregroundStyle(Color.modernSpecial)
                            }
                        }
                        .padding(ModernSpacing.sm)
                        .background {
                            RoundedRectangle(cornerRadius: ModernRadius.xs)
                                .fill(Color.modernSpecialSoft)
                        }
                    }
                }
            }
        }
        .frame(maxWidth: .infinity)
        .padding(ModernSpacing.lg)
        .modernCard(.elevated)
    }
    
    // MARK: - ÈÅ∏ÊìáÈ°åÈÅ∏È†Ö
    
    private func multipleChoiceOptions(question: QuizQuestion) -> some View {
        VStack(spacing: ModernSpacing.sm) {
            if let options = question.options {
                ForEach(Array(options.enumerated()), id: \.offset) { index, option in
                    optionButton(
                        index: index,
                        text: option,
                        isSelected: selectedIndex == index,
                        isCorrect: showingResult ? index == question.correctIndex : nil
                    )
                }
            }
        }
    }
    
    private func optionButton(index: Int, text: String, isSelected: Bool, isCorrect: Bool?) -> some View {
        Button(action: {
            guard !isAnswered else { return }
            selectedIndex = index
            selectedAnswer = text
        }) {
            HStack(spacing: ModernSpacing.md) {
                // ÈÅ∏È†ÖÊ®ôË®ò
                ZStack {
                    Circle()
                        .fill(optionCircleBackgroundColor(isSelected: isSelected, isCorrect: isCorrect))
                        .frame(width: 28, height: 28)
                    
                    Text(optionLabel(for: index))
                        .font(.appHeadline(for: "ÈÅ∏È†ÖÊ®ôË®ò"))
                        .foregroundStyle(optionCircleTextColor(isSelected: isSelected, isCorrect: isCorrect))
                }
                
                // ÈÅ∏È†ÖÊñáÂ≠ó
                Text(text)
                    .font(.appHeadline(for: "ÈÅ∏È†ÖÊñáÂ≠ó"))
                    .foregroundStyle(optionTextColor(isSelected: isSelected, isCorrect: isCorrect))
                    .multilineTextAlignment(.leading)
                
                Spacer()
                
                // ÁµêÊûúÂúñÁ§∫
                if showingResult {
                    if isCorrect == true {
                        Image(systemName: "checkmark.circle.fill")
                            .font(.appHeadline())
                            .foregroundStyle(Color.modernSuccess)
                    } else if isSelected && isCorrect == false {
                        Image(systemName: "xmark.circle.fill")
                            .font(.appHeadline())
                            .foregroundStyle(Color.modernError)
                    }
                }
            }
            .padding(ModernSpacing.md)
            .background {
                RoundedRectangle(cornerRadius: ModernRadius.sm)
                    .fill(optionBackgroundColor(isSelected: isSelected, isCorrect: isCorrect))
                    .overlay {
                        RoundedRectangle(cornerRadius: ModernRadius.sm)
                            .stroke(optionBorderColor(isSelected: isSelected, isCorrect: isCorrect), lineWidth: 2)
                    }
            }
        }
        .disabled(isAnswered)
        .buttonStyle(.plain)
    }
    
    // MARK: - Ë™ûÂ¢ÉÂ°´Á©∫Ëº∏ÂÖ•
    
    private func contextFillInput(question: QuizQuestion) -> some View {
        VStack(spacing: ModernSpacing.md) {
            TextField("Ë´ãËº∏ÂÖ•ÂñÆÂ≠ó", text: $userInput)
                .font(.appTitle2(for: "Ëº∏ÂÖ•ÊñáÂ≠ó"))
                .padding(ModernSpacing.md)
                .modernInput(isFocused: false)
                .disabled(isAnswered)
                .textInputAutocapitalization(.never)
                .autocorrectionDisabled()
            
            if !userInput.isEmpty && !isAnswered {
                Text("‰Ω†ÁöÑÁ≠îÊ°àÔºö\(userInput)")
                    .font(.appSubheadline(for: "Áî®Êà∂Á≠îÊ°à"))
                    .foregroundStyle(Color.modernSpecial)
            }
        }
    }
    
    // MARK: - ÁµêÊûúÂç°Áâá
    
    private func resultCard(question: QuizQuestion) -> some View {
        VStack(spacing: ModernSpacing.md) {
            // ÁµêÊûúÊ®ôÈ°å
            HStack {
                Image(systemName: isCorrectAnswer(question: question) ? "checkmark.circle.fill" : "xmark.circle.fill")
                    .font(.appTitle())
                    .foregroundStyle(isCorrectAnswer(question: question) ? Color.modernSuccess : Color.modernError)
                
                Text(isCorrectAnswer(question: question) ? "Á≠îÂ∞ç‰∫ÜÔºÅ" : "Á≠îÈåØ‰∫Ü")
                    .font(.appTitle2(for: "ÁµêÊûúÊ®ôÈ°å"))
                    .foregroundStyle(isCorrectAnswer(question: question) ? Color.modernSuccess : Color.modernError)
                
                Spacer()
            }
            
            // Ê≠£Á¢∫Á≠îÊ°à
            if type == .contextFill {
                VStack(alignment: .leading, spacing: ModernSpacing.xs) {
                    Text("Ê≠£Á¢∫Á≠îÊ°àÔºö")
                        .font(.appSubheadline(for: "Ê≠£Á¢∫Á≠îÊ°àÊ®ôÁ±§"))
                        .foregroundStyle(Color.modernTextSecondary)
                    
                    if let targetWord = question.targetWord {
                        Text(targetWord)
                            .font(.appTitle2(for: "Ê≠£Á¢∫Á≠îÊ°à"))
                            .foregroundStyle(Color.modernSuccess)
                    }
                    
                    if let completeSentence = question.completeSentence {
                        Text("ÂÆåÊï¥Âè•Â≠êÔºö")
                            .font(.appCaption(for: "ÂÆåÊï¥Âè•Â≠êÊ®ôÁ±§"))
                            .foregroundStyle(Color.modernTextSecondary)
                        
                        Text(completeSentence)
                            .font(.appSubheadline(for: "ÂÆåÊï¥Âè•Â≠ê"))
                            .foregroundStyle(Color.modernTextPrimary)
                    }
                }
            }
            
            // Ëß£Èáã
            if let explanation = question.explanation {
                VStack(alignment: .leading, spacing: ModernSpacing.xs) {
                    Text("Ëß£ÈáãÔºö")
                        .font(.appCaption(for: "Ëß£ÈáãÊ®ôÁ±§"))
                        .foregroundStyle(Color.modernTextSecondary)
                    
                    Text(explanation)
                        .font(.appSubheadline(for: "Ëß£ÈáãÂÖßÂÆπ"))
                        .foregroundStyle(Color.modernTextPrimary)
                }
            }
        }
        .padding(ModernSpacing.md)
        .background {
            RoundedRectangle(cornerRadius: ModernRadius.sm)
                .fill(Color.modernSurface)
        }
    }
    
    // MARK: - Â∫ïÈÉ®ÊéßÂà∂ÂçÄÂüü
    
    private var bottomControlArea: some View {
        VStack(spacing: ModernSpacing.md) {
            if !isAnswered {
                // Êèê‰∫§Á≠îÊ°àÊåâÈàï
                ModernButton(
                    isSubmittingReview ? "" : "Êèê‰∫§Á≠îÊ°à",
                    style: canSubmit ? .primary : .secondary,
                    isLoading: isSubmittingReview,
                    isEnabled: canSubmit && !isSubmittingReview
                ) {
                    submitAnswer()
                }
            } else {
                // ‰∏ã‰∏ÄÈ°åÊåâÈàï
                ModernButton(
                    currentIndex < quiz.questions.count - 1 ? "‰∏ã‰∏ÄÈ°å" : "ÂÆåÊàêÊ∏¨È©ó",
                    icon: currentIndex < quiz.questions.count - 1 ? "arrow.right" : "checkmark",
                    style: .primary
                ) {
                    nextQuestion()
                }
            }
        }
        .padding(ModernSpacing.md)
    }
    
    // MARK: - ÂÆåÊàêÈ†ÅÈù¢
    
    private var studyCompleteView: some View {
        VStack(spacing: ModernSpacing.xxl) {
            Image(systemName: "star.circle.fill")
                .font(.appLargeTitle())
                .foregroundStyle(Color.modernSpecial)
            
            Text("Ê∏¨È©óÂÆåÊàêÔºÅ")
                .font(.appLargeTitle(for: "ÂÆåÊàêÊ®ôÈ°å"))
                .foregroundStyle(Color.modernTextPrimary)
            
            VStack(spacing: ModernSpacing.sm) {
                Text("Á≠îÂ∞çÁéá: \(safeFinalAccuracyPercentage)%")
                    .font(.appTitle2(for: "Á≠îÂ∞çÁéá"))
                    .foregroundStyle(correctAnswers >= quiz.questions.count / 2 ? Color.modernSuccess : Color.modernWarning)
                
                Text("ÂÖ±ÂÆåÊàê \(quiz.questions.count) È°å")
                    .font(.appHeadline(for: "È°åÁõÆÊï∏Èáè"))
                    .foregroundStyle(Color.modernTextSecondary)
                
                Text("Ê∏¨È©óÊôÇÈñì: \(formatStudyTime())")
                    .font(.appSubheadline(for: "Ê∏¨È©óÊôÇÈñì"))
                    .foregroundStyle(Color.modernTextSecondary)
            }
            
            ModernButton(
                "ÂÆåÊàêÂ≠∏Áøí",
                style: .primary
            ) {
                completeStudy()
            }
            .padding(.horizontal, ModernSpacing.lg)
        }
        .padding(ModernSpacing.lg)
    }
    
    // MARK: - Ë®àÁÆóÂ±¨ÊÄß
    
    private var canSubmit: Bool {
        if type == .multipleChoice {
            return selectedIndex != nil
        } else {
            return !userInput.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
        }
    }
    
    // MARK: - ÊñπÊ≥ï
    
    private func submitAnswer() {
        guard let question = currentQuestion else { return }
        
        let responseTime = Date().timeIntervalSince(questionStartTime)
        let isCorrect = isCorrectAnswer(question: question)
        
        if isCorrect {
            correctAnswers += 1
        }
        
        isAnswered = true
        showingResult = true
        
        // Êèê‰∫§Âà∞ÂæåÁ´Ø
        Task {
            await submitReviewToBackend(
                wordId: question.wordId,
                isCorrect: isCorrect,
                responseTime: responseTime
            )
        }
    }
    
    private func nextQuestion() {
        if currentIndex < quiz.questions.count - 1 {
            currentIndex += 1
            resetQuestionState()
        } else {
            // ÂÆåÊàêÊ∏¨È©ó
            currentIndex += 1
        }
    }
    
    private func resetQuestionState() {
        selectedAnswer = nil
        selectedIndex = nil
        userInput = ""
        isAnswered = false
        showingResult = false
        questionStartTime = Date()
    }
    
    private func isCorrectAnswer(question: QuizQuestion) -> Bool {
        if type == .multipleChoice {
            return selectedIndex == question.correctIndex
        } else {
            let userAnswer = userInput.trimmingCharacters(in: .whitespacesAndNewlines).lowercased()
            let correctAnswer = question.targetWord?.lowercased() ?? ""
            return userAnswer == correctAnswer
        }
    }
    
    private func completeStudy() {
        let studyTime = Date().timeIntervalSince(startTime)
        let summary = StudySummary(
            totalQuestions: quiz.questions.count,
            correctAnswers: correctAnswers,
            studyTime: studyTime,
            wordsStudied: studiedWords
        )
        
        onComplete(summary)
    }
    
    @MainActor
    private func submitReviewToBackend(wordId: Int, isCorrect: Bool, responseTime: TimeInterval) async {
        isSubmittingReview = true
        
        let submission = ReviewSubmission(
            wordId: wordId,
            isCorrect: isCorrect,
            reviewType: type.rawValue,
            responseTime: responseTime
        )
        
        do {
            let result = try await vocabularyService.submitReview(submission: submission)
            studiedWords.append(result.updatedWord)
        } catch {
            print("Êèê‰∫§Ë§áÁøíÁµêÊûúÂ§±Êïó: \(error)")
        }
        
        isSubmittingReview = false
    }
    
    private func formatStudyTime() -> String {
        let totalSeconds = Int(Date().timeIntervalSince(startTime))
        let minutes = totalSeconds / 60
        let seconds = totalSeconds % 60
        return String(format: "%d:%02d", minutes, seconds)
    }
    
    // MARK: - È°èËâ≤ÂíåÊ®£ÂºèËºîÂä©ÊñπÊ≥ï
    
    private func optionLabel(for index: Int) -> String {
        return String(UnicodeScalar(65 + index)!) // A, B, C, D
    }
    
    private func optionCircleBackgroundColor(isSelected: Bool, isCorrect: Bool?) -> Color {
        if let isCorrect = isCorrect {
            if isCorrect {
                return Color.modernSuccess
            } else if isSelected {
                return Color.modernError
            } else {
                return Color.modernTextTertiary
            }
        }
        return isSelected ? Color.modernAccent : Color.modernTextTertiary
    }
    
    private func optionCircleTextColor(isSelected: Bool, isCorrect: Bool?) -> Color {
        if showingResult {
            if let isCorrect = isCorrect {
                return isCorrect ? .white : (isSelected ? .white : Color.modernTextPrimary)
            }
        }
        return isSelected ? .white : Color.modernTextPrimary
    }
    
    private func optionTextColor(isSelected: Bool, isCorrect: Bool?) -> Color {
        if showingResult {
            if let isCorrect = isCorrect {
                return isCorrect ? Color.modernSuccess : (isSelected ? Color.modernError : Color.modernTextPrimary)
            }
        }
        return isSelected ? Color.modernAccent : Color.modernTextPrimary
    }
    
    private func optionBackgroundColor(isSelected: Bool, isCorrect: Bool?) -> Color {
        if let isCorrect = isCorrect {
            if isCorrect {
                return Color.modernSuccess.opacity(0.1)
            } else if isSelected {
                return Color.modernError.opacity(0.1)
            } else {
                return Color.modernSurface
            }
        }
        return isSelected ? Color.modernAccentSoft : Color.modernSurface
    }
    
    private func optionBorderColor(isSelected: Bool, isCorrect: Bool?) -> Color {
        if let isCorrect = isCorrect {
            if isCorrect {
                return Color.modernSuccess
            } else if isSelected {
                return Color.modernError
            } else {
                return Color.modernBorder
            }
        }
        return isSelected ? Color.modernAccent : Color.modernBorder
    }
    
    // MARK: - ÂÆâÂÖ®Ë®àÁÆóÊñπÊ≥ï
    
    private var safeAccuracyPercentage: Int {
        guard currentIndex > 0 else { return 0 }
        let accuracy = Double(correctAnswers) / Double(currentIndex) * 100
        if accuracy.isNaN || accuracy.isInfinite {
            return 0
        }
        return max(0, min(100, Int(accuracy.rounded())))
    }
    
    private var safeFinalAccuracyPercentage: Int {
        guard quiz.questions.count > 0 else { return 0 }
        let accuracy = Double(correctAnswers) / Double(quiz.questions.count) * 100
        if accuracy.isNaN || accuracy.isInfinite {
            return 0
        }
        return max(0, min(100, Int(accuracy.rounded())))
    }
}